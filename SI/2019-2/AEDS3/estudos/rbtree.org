#+TITLE:       Árvore Red-Black
#+AUTHOR:      Lucas S. Vieira
#+EMAIL:       lucasvieira@protonmail.com
#+DESCRIPTION: Implementação de uma árvore AVL em C++.
#+KEYWORDS:    rb, cpp, documentação, algoritmos, estruturas de dados
#+LANGUAGE:    pt_BR
#+PROPERTY:    header-args:cpp :eval no :main no :tangle rbtree.cpp
#+PROPERTY:    header-args:dot :cache yes :cmdline -Kdot -Tpng
#+STARTUP:     content
#+SETUPFILE:   ReadTheOrg.setup

#+TODO: Remoção!

:LATEX_PROPERTIES:

# Preamble
#+LATEX_CLASS: abntex2

#+LATEX_CLASS_OPTIONS: [article,12pt,openany,oneside,a4paper,chapter=TITLE,hyphen,english,brazil,sumario=tradicional]

#+LATEX_HEADER: \usepackage[brazil]{babel}
#+LATEX_HEADER: \usepackage{times}
#+LATEX_HEADER: \usepackage[utf8x]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \usepackage{titlesec}
#+LATEX_HEADER: \usepackage[english, hyperpageref]{backref}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage[alf,abnt-emphasize=bf,abnt-doi=link]{abntex2cite}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \usepackage{tikz}
# #+LATEX_HEADER: \usepackage{draftwatermark}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage{titling}

# Remove colorization of links
#+LATEX_HEADER: \definecolor{blue}{RGB}{41,5,195}
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \hypersetup{
# #+LATEX_HEADER:     pdftitle={%t},
# #+LATEX_HEADER:     pdfauthor={%a},
# #+LATEX_HEADER:     pdfkeywords={%k},
# #+LATEX_HEADER:     pdfsubject={%d},
# #+LATEX_HEADER:     pdfcreator={%c},
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     linkcolor=black,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     filecolor=black,
#+LATEX_HEADER:     urlcolor=blue,
#+LATEX_HEADER:     bookmarksdepth=4
#+LATEX_HEADER: }
#+LATEX_HEADER: \makeatother
#+BIND: org-latex-hyperref-template ""

# Make watermark softer
# #+LATEX_HEADER: \SetWatermarkLightness{0.85}

# Seções e subseções em Times
#+LATEX_HEADER: \titleformat{\section}{\normalfont\normalsize\bfseries\uppercase}{\thesection. }{0pt}{}
#+LATEX_HEADER: \titleformat{\subsection}{\normalfont\normalsize\bfseries}{\thesubsection. }{0pt}{\space}
#+LATEX_HEADER: \titleformat{\subsubsection}{\normalfont\normalsize\bfseries}{\thesubsubsection. }{0pt}{\space}
#+LATEX_HEADER: \titleformat{\paragraph}{\normalfont\normalsize\itshape}{}{0pt}{\theparagraph\space}

# Tamanhos e fontes de seções
#+LATEX_HEADER: \renewcommand{\ABNTEXchapterfontsize}{\normalsize} 
#+LATEX_HEADER: \renewcommand{\ABNTEXsectionfontsize}{\normalsize} 
#+LATEX_HEADER: \renewcommand{\ABNTEXsubsectionfontsize}{\normalsize} 
#+LATEX_HEADER: \renewcommand{\ABNTEXsubsubsectionfontsize}{\normalsize}

#+LATEX_HEADER: \renewcommand{\ABNTEXchapterfont}{\normalfont\bfseries}
#+LATEX_HEADER: \renewcommand{\ABNTEXsectionfont}{\normalfont\bfseries}
#+LATEX_HEADER: \renewcommand{\ABNTEXsubsectionfont}{\normalfont}
#+LATEX_HEADER: \renewcommand{\ABNTEXsubsubsectionfont}{\normalfont}


# Spacing
#+LATEX: \frenchspacing
:END:

:CODE_BLOCK_STYLE:
#+LATEX_HEADER: \usepackage{minted}

# List of styles: https://help.farbox.com/pygments.html

# Monokai style
#+LATEX_HEADER: \usemintedstyle{monokai}
#+LATEX_HEADER: \definecolor{monokaibg}{HTML}{383838}
#+LATEX_HEADER: \setminted{bgcolor=monokaibg}

# Perldoc style
# #+LATEX_HEADER: \usemintedstyle{perldoc}
# #+LATEX_HEADER: \definecolor{perldocbg}{HTML}{ffffcc}
# #+LATEX_HEADER: \setminted{bgcolor=perldocbg}

# Manni style
# #+LATEX_HEADER: \usemintedstyle{manni}
# #+LATEX_HEADER: \definecolor{lightgrey}{HTML}{efefef}
# #+LATEX_HEADER: \setminted{bgcolor=lightgrey}

# Line numbers
#+LATEX_HEADER: \setminted{linenos=true}

# Font size
#+LATEX_HEADER: \setminted{fontsize=\small, baselinestretch=1}

# Line breaking
#+LATEX_HEADER: \setminted{breaklines=true}

# Tabs
#+LATEX_HEADER: \setminted{obeytabs}
:END:

# #+LATEX: \frontmatter

* Introdução
:PROPERTIES:
:UNNUMBERED: t
:END:

Este documento visa implementar uma árvore rubro-negra utilizando a
linguagem C++ (2014). A árvore é implementada utilizando o recurso de
/template/ para sua generalização.

Este código foi feito no editor Emacs através do formato Org, podendo
ser transformado em um único arquivo de código.

* Propriedades das árvores vermelho-preto

Uma árvore vermelho-preto (ou RB, ou rubro-negra) é uma árvore de
busca binária, com um /bit/ ou uma /bandeira/ extra de armazenamento por
nó: sua /cor/, que pode ser /vermelha/ ou /preta/ cite:cormen. Através da
restrição das cores dos nós em qualquer caminho simples da raiz até as
folhas, as árvores vermelho-preto garantem que nenhum destes caminhos
seja maior que o /dobro/ do tamanho de qualquer outro caminho.

Uma árvore vermelho-preto é, portanto, /aproximadamente balanceada/.

citeonline:cormen postula algumas /propriedades vermelho-preto/, que
instituem a forma como os ramos das árvores serão gerenciados:

1. Todo nó é vermelho ou preto.
2. A raiz é preta.
3. Toda folha (=NIL=) é preta.
4. Se um nó é /vermelho/, então seus filhos são /pretos/.
5. Para cada nó, todos os caminhos simples do nó até as folhas
   descendentes contém o mesmo número de nós pretos.

O balanceamento de uma árvore RB envolve a verificação retroativa
destes postulados, à medida que o nó é inserido.

* Cabeçalhos e bibliotecas

Começamos identificando cabeçalhos de bibliotecas úteis a serem
utilizadas. Temos bibliotecas para Entrada e Saída e para Matemática
em geral.

Também utilizaremos as estruturas =std::queue= e =std::vector= como
utilitários para escrita da árvore em níveis e para manipulação de
elementos a serem adicionados na árvore, respectivamente.

#+begin_src cpp
#include <iostream>
#include <cmath>
#include <queue>
#include <vector>
#include <fstream>
#include <string>
#include <cstdlib>
#include <ctime>
#+end_src

* Estilo de impressão
<<sec:impressao_enum>>

A enumeração a seguir descreve oito estilos de impressão para uma
árvore RB. Estes estilos são:

- /In order/: Descreve os elementos em ordem crescente. Determina a
  impressão recursiva da sub-árvore da esquerda, do elemento atual, e
  a impressão recursiva da árvore da direita.
- /Preorder/: Imprime o elemento atual e em seguida imprime
  recursivamente as sub-árvores da esquerda e da direita.
- /Post-order/: Imprime primeiramente as sub-árvores da esquerda e da
  direita, e então imprime o elemento atual.
- /Level/: Imprime sequencialmente a árvore, nível a nível.
- /Triangle/: Funciona como /level/, porém imprime cada nível em uma
  linha. Ponteiros nulos também serão impressos por conveniência.
- /GraphViz:/ Imprime o código da árvore para a ferramenta GraphViz, de
  forma que a mesma possa ser renderizada em uma imagem.
- /GraphViz (Show):/ Realiza o mesmo que a impressão /GraphViz/, porém em
  um arquivo-texto, e então invoca o compilador para a imagem, e em
  sequência, o visualizador de imagens.
- /XDot:/ Realiza o mesmo que a impressão /GraphViz/, porém em um
  arquivo-texto, e então invoca a ferramenta =xdot= para visualizar a
  árvore interativamente.

#+begin_src cpp
enum TreePrintStyle
{
    TREEPRINT_INORDER,
    TREEPRINT_PREORDER,
    TREEPRINT_POSTORDER,
    TREEPRINT_LEVEL,
    TREEPRINT_TRIANGLE,
    TREEPRINT_GRAPHVIZ,
    TREESHOW_GRAPHVIZ,
    TREESHOW_XDOT
};
#+end_src

* Início da classe RBTree
:PROPERTIES:
:UNNUMBERED: t
:END:

A classe =RBTree= é uma classe construída utilizando /templates/. Desta
forma, esta classe pode ser generalizada para qualquer tipo
comparável[fn:1].

Iniciamos pela abertura do escopo da classe.

#+begin_src cpp
template<typename T>
class RBTree
{
#+end_src

* Elementos privados
** Início dos elementos privados
:PROPERTIES:
:UNNUMBERED: t
:END:

Os elementos após a próxima linha são acessíveis apenas /no escopo da
classe =RBTree=/.

#+begin_src cpp
private:
#+end_src

** Cores dos nós

As cores de um nó são instituidas através da enumeração a seguir. Esta
enumeração isenta a classe de utilizar um mero identificador =int= em
seus nós, através de algo mais idiomático.

#+begin_src cpp
enum COLOR
{
    RED,
    BLACK
};
#+end_src

** Estrutura interna do nó

A estrutura a seguir descreve um nó qualquer da árvore. Esta estrutura
é acessível apenas no escopo interno da mesma. Portanto, é bom
observar que não será possível "exportar" ponteiros de nós
pertencentes à árvore.

É interessante destacar que este nó possui um campo =color=, diferente
do que se esperaria em uma árvore binária como a AVL, por exemplo.

Ademais, um nó também possui um ponteiro para seu pai. Este ponteiro é
interessante para facilitar a implementação do consertamento de cores,
durante o processo de inserção.

#+begin_src cpp
struct node_t
{
    T      info;
    COLOR  color;
    node_t *left;
    node_t *right;
    node_t *parent;
};
#+end_src

** Ponteiro para a raiz

Este campo privado da classe armazena um ponteiro para o nó raiz da
árvore.

#+begin_src cpp
node_t *_root;
#+end_src

** Altura de um nó

Este método calcula a altura de um nó arbitrário da árvore.

A altura de um nó é descrita sob as seguintes regras:

- =-1= quando o nó atual é nulo;
- =0= quando o nó atual é um /nó-folha/;
- =1 + a=, para um valor ~a~ que seja o maior tamanho entre as alturas
  dos nós à esquerda e à direita.

Retornar /-1/ para um nó nulo não é o procedimento padrão para árvores
RB, mas este valor acaba não afetando no cálculo recursivo da altura
de um certo nó, uma vez que utilizamos =std::max= para obtermos sempre o
maior valor.

#+begin_src cpp
int _height(const node_t *node) const
{
    if(!node) return -1;
        
    if(!node->left && !node->right)
        return 0;

    return 1 + std::max(_height(node->left),
                        _height(node->right));
}
#+end_src

** Consertando cores

Em cada alteração realizada na árvore rubro-negra, precisaremos
verificar os postulados para este tipo de árvore de forma retroativa,
bem como modificar as cores dos nós, se necessário.

*** Rotação à esquerda

#+NAME: fig:lrot
#+begin_src dot :file img/lrot.png
graph G {
      graph[ranksep=0.3];
      bgcolor="#00000000";
      node [shape=circle];

      subgraph cluster_0 {
          label="Pré-rotação";
          a0[label="a"];
          b0[label="b"];
          c0[label="c"];
          
          LA0[label="X", shape=plaintext];
          LB0[label="Y", shape=plaintext];
          LC0[label="Z", shape=plaintext];
          RC0[label="W", shape=plaintext];

          a0:sw -- LA0:n;
          a0:se -- b0;
          b0:sw -- LB0:n;
          b0:se -- c0;
          c0:sw -- LC0:n;
          c0:se -- RC0:n;
      }

      subgraph cluster_1 {
          label="Após rotação à esquerda";
          a1[label="a"];        
          b1[label="b"];
          c1[label="c"];
          
          LA1[label="X", shape=plaintext];
          LB1[label="Y", shape=plaintext];
          LC1[label="Z", shape=plaintext];
          RC1[label="W", shape=plaintext];
          
          b1:sw -- a1;
          b1:se -- c1;
          a1:sw -- LA1:n;
          a1:se -- LB1:n;
          c1:sw -- LC1:n;
          c1:se -- RC1:n;
      }
}
#+end_src

#+RESULTS[1f7013c74a44e3569f7f4399a20dc238bad6f31c]: fig:lrot
[[file:img/lrot.png]]

#+begin_src cpp
void _lrot(node_t*& root, node_t*& ptr)
{
    node_t *right_ptr = ptr->right;
    ptr->right = right_ptr->left;

    if(ptr->right) {
        ptr->right->parent = ptr;
    }

    right_ptr->parent = ptr->parent;

    if(!ptr->parent) {
        root = right_ptr;
    } else if(ptr == ptr->parent->left) {
        ptr->parent->left = right_ptr;
    } else {
        ptr->parent->right = right_ptr;
    }

    right_ptr->left = ptr;
    ptr->parent = right_ptr;
}
#+end_src

*** Rotação à direita

#+NAME: fig:rrot
#+begin_src dot :file img/rrot.png
graph G {
      graph[ranksep=0.3];
      bgcolor="#00000000";
      node [shape=circle];

      subgraph cluster_0 {
          label="Pré-rotação";
          a0[label="a"];
          b0[label="b"];
          c0[label="c"];
          
          RA0[label="W", shape=plaintext];
          RB0[label="Z", shape=plaintext];
          LC0[label="X", shape=plaintext];
          RC0[label="Y", shape=plaintext];

          a0:sw -- b0;
          a0:se -- RA0:n;
          b0:sw -- c0;
          b0:se -- RB0:n;
          c0:sw -- LC0:n;
          c0:se -- RC0:n;
      }

      subgraph cluster_1 {
          label="Após rotação à direita";
          a1[label="a"];        
          b1[label="b"];
          c1[label="c"];
          
          RA1[label="W", shape=plaintext];
          RB1[label="Z", shape=plaintext];
          LC1[label="X", shape=plaintext];
          RC1[label="Y", shape=plaintext];
          
          b1:sw -- c1;
          b1:se -- a1;
          a1:sw -- RB1:n;
          a1:se -- RA1:n;
          c1:sw -- LC1:n;
          c1:se -- RC1:n;
      }
}
#+end_src

#+RESULTS[89f1fb7c33c0b05c2d595aa558a2b6a3f35aa447]: fig:rrot
[[file:img/rrot.png]] 

#+begin_src cpp
void _rrot(node_t*& root, node_t*& ptr)
{
    node_t *left_ptr = ptr->left;
    ptr->left = left_ptr->right;

    if(ptr->left) {
        ptr->left->parent = ptr;
    }

    left_ptr->parent = ptr->parent;

    if(!ptr->parent) {
        root = left_ptr;
    } else if(ptr == ptr->parent->left) {
        ptr->parent->left = left_ptr;
    } else {
        ptr->parent->right = left_ptr;
    }

    left_ptr->right = ptr;
    ptr->parent = left_ptr;
}
#+end_src

*** Conserto

O método =_fixup= realiza o /conserto/ das cores na árvore.

Esta função verifica pela violação das duas únicas propriedades que
poderiam ser violadas:

- A raiz é preta.
- Se um nó é /vermelho/, então seus filhos são /pretos/.

A propriedade 2 é violada quando o nó inserido é a raiz, e a
propriedade 4 é violada quando o pai do nó inserido é vermelho.

Para o caso da inserção de um nó que será a raiz, basta recolori-lo de
preto.

A inserção do nó em qualquer outro local da árvore demanda uma
verificação retroativa demanda a verificação de quatro casos,
dependendo do lado onde o /tio/ do nó atual está (se é filho esquerdo ou
direito do avô).

*CASO 1*: Se o /tio/ é VERMELHO, então basta recolorir os nós a rigor: o
/pai/ e o /tio/ passam a ser PRETOS, e o /avô/ passa a ser VERMELHO; mude o
foco para o /avô/.

#+begin_src dot :file img/case1.png
graph G {
      bgcolor = "#00000000";
      graph[nodesep="0.5", ranksep = "0.2", fixedsize = true];
      node[shape=circle, fontcolor=white, fillcolor=white, style=filled];

      subgraph cluster_0 {
          label="Antes de recolorir";
          g1[label="G", fontcolor=black];
      	g1:sw -- p1:n;
	        g1:se -- u1:n;
	        p1[fillcolor=red, label="P"];
	        p1:sw -- x1:n;
	        u1[fillcolor=red, label="U"];
      	x1[fillcolor=red, label="X"];
	        t11[label="T1", shape=plain, style="", fontcolor=black];
	        t21[label="T2", shape=plain, style="", fontcolor=black];
	        t31[label="T3", shape=plain, style="", fontcolor=black];
	        t41[label="T4", shape=plain, style="", fontcolor=black];
	        t51[label="T5", shape=plain, style="", fontcolor=black];
		x1:sw -- t11:n;
		x1:se -- t21:n;
		p1:se -- t31:n;
		u1:sw -- t41:n;
		u1:se -- t51:n;
      }

      subgraph cluster_1 {
          label="Depois de recolorir";
          g2[fillcolor=red, label="G"];
      	g2:sw -- p2:n;
	        g2:se -- u2:n;
	        p2[fillcolor=black, label="P"];
	        p2:sw -- x2:n;
	        u2[fillcolor=black, label="U"];
      	x2[fillcolor=red, label="X"];
	        t12[label="T1", shape=plain, style="", fontcolor=black];
	        t22[label="T2", shape=plain, style="", fontcolor=black];
	        t32[label="T3", shape=plain, style="", fontcolor=black];
	        t42[label="T4", shape=plain, style="", fontcolor=black];
	        t52[label="T5", shape=plain, style="", fontcolor=black];
		x2:sw -- t12:n;
		x2:se -- t22:n;
		p2:se -- t32:n;
		u2:sw -- t42:n;
		u2:se -- t52:n;
      }
}
#+end_src

#+RESULTS[f81f7f9f4af00299647c6f17f8378ad69326faab]:
[[file:img/case1.png]]

Se o /tio/ é PRETO, então precisamos verificar dois casos.

*CASO 3*: Se um nó VERMELHO é filho esquerdo de um pai VERMELHO, então,
realizamos uma rotação /à direita/ no pai, de forma que o /pai/ tome o
lugar do /avô/. Ademais, o /pai/ e o /avô/ trocam, entre si, suas cores.
Mude o foco para o antigo /pai/.

#+begin_src dot :file img/case3.png
graph G {
      bgcolor = "#00000000";
      graph[nodesep="0.5", ranksep = "0.2", fixedsize = true];
      node[shape=circle, fontcolor=white, fillcolor=white, style=filled];

      subgraph cluster_0 {
          label="Antes da rotação à direita";
          g1[label="G", fontcolor=black];
      	g1:sw -- p1:n;
	        g1:se -- u1:n;
	        p1[fillcolor=red, label="P"];
	        p1:sw -- x1:n;
	        u1[fillcolor=black, label="U"];
      	x1[fillcolor=red, label="X"];
	        t11[label="T1", shape=plain, style="", fontcolor=black];
	        t21[label="T2", shape=plain, style="", fontcolor=black];
	        t31[label="T3", shape=plain, style="", fontcolor=black];
	        t41[label="T4", shape=plain, style="", fontcolor=black];
	        t51[label="T5", shape=plain, style="", fontcolor=black];
	        x1:sw -- t11:n;
		x1:se -- t21:n;
		p1:se -- t31:n;
		u1:sw -- t41:n;
		u1:se -- t51:n;
      }

      subgraph cluster_1 {
          label="Depois da rotação à direita";
          g2[fillcolor=red, label="G"];
	        p2[label="P", fontcolor=black];
	        u2[fillcolor=black, label="U"];
      	x2[fillcolor=red, label="X"];
	        p2:sw -- x2:n;
		p2:se -- g2:n;
		g2:se -- u2:n;
		t12[label="T1", shape=plain, style="", fontcolor=black];
	        t22[label="T2", shape=plain, style="", fontcolor=black];
	        t32[label="T3", shape=plain, style="", fontcolor=black];
	        t42[label="T4", shape=plain, style="", fontcolor=black];
	        t52[label="T5", shape=plain, style="", fontcolor=black];
	        x2:sw -- t12:n;
		x2:se -- t22:n;
		g2:sw -- t32:n;
		u2:sw -- t42:n;
		u2:se -- t52:n;
      }
}
#+end_src

#+RESULTS[29e5d412da5a808fac544f4a358725a9a98f6e4a]:
[[file:img/case3.png]]

*CASO 2*: Se um nó VERMELHO é filho direito de um /pai/ VERMELHO, então,
realizamos uma rotação /à esquerda/ no filho. A árvore acaba caindo
novamente no *CASO 3*; mude o foco para o antigo /pai/.

#+begin_src dot :file img/case2.png
graph G {
      bgcolor = "#00000000";
      graph[nodesep="0.5", ranksep = "0.2", fixedsize = true];
      node[shape=circle, fontcolor=white, fillcolor=white, style=filled];

      subgraph cluster_0 {
          label="Antes da rotação à esquerda";
          g1[label="G", fontcolor=black];
      	g1:sw -- p1:n;
	        g1:se -- u1:n;
	        p1[fillcolor=red, label="P"];
	        p1:se -- x1:n;
	        u1[fillcolor=black, label="U"];
      	x1[fillcolor=red, label="X"];
		t11[label="T1", shape=plain, style="", fontcolor=black];
	        t21[label="T2", shape=plain, style="", fontcolor=black];
	        t31[label="T3", shape=plain, style="", fontcolor=black];
	        t41[label="T4", shape=plain, style="", fontcolor=black];
	        t51[label="T5", shape=plain, style="", fontcolor=black];
		p1:sw -- t11:n;
		x1:sw -- t21:n;
		x1:se -- t31:n;
		u1:sw -- t41:n;
		u1:se -- t51:n;
	    }

      subgraph cluster_1 {
          label="Depois da rotação à esquerda";
          g2[label="G", fontcolor=black];
	        p2[fillcolor=red, label="P"];
	        u2[fillcolor=black, label="U"];
      	x2[fillcolor=red, label="X"];
	        g2:sw -- x2:n;
		g2:se -- u2:n;
		x2:sw -- p2:n;
		t12[label="T1", shape=plain, style="", fontcolor=black];
	        t22[label="T2", shape=plain, style="", fontcolor=black];
	        t32[label="T3", shape=plain, style="", fontcolor=black];
	        t42[label="T4", shape=plain, style="", fontcolor=black];
	        t52[label="T5", shape=plain, style="", fontcolor=black];
		p2:sw -- t12:n;
		p2:se -- t22:n;
		x2:se -- t32:n;
		u2:sw -- t42:n;
		u2:se -- t52:n;
      }

      subgraph cluster_2 {
          label="Após Caso 3 (foco em P)";
          g3[fillcolor=red, label="G"];
	        x3[label="X", fontcolor=black];
	        u3[fillcolor=black, label="U"];
      	p3[fillcolor=red, label="P"];
	        x3:sw -- p3:n;
		x3:se -- g3:n;
		g3:se -- u3:n;
		t13[label="T1", shape=plain, style="", fontcolor=black];
	        t23[label="T2", shape=plain, style="", fontcolor=black];
	        t33[label="T3", shape=plain, style="", fontcolor=black];
	        t43[label="T4", shape=plain, style="", fontcolor=black];
	        t53[label="T5", shape=plain, style="", fontcolor=black];
		p3:sw -- t13:n;
		p3:se -- t23:n;
		g3:sw -- t33:n;
		u3:sw -- t43:n;
		u3:se -- t53:n;
      }
}
#+end_src

#+RESULTS[3203e4e5c39c5256f964eccbb6a41bf58e90add5]:
[[file:img/case2.png]]

**** Implementação

#+begin_src cpp
void _fixup(node_t*& root, node_t*& ptr)
{
    node_t* parent_ptr      = nullptr;
    node_t* grandparent_ptr = nullptr;

    while((ptr != _root) &&
          (ptr->color == RED) &&
          (ptr->parent->color == RED))
    {
        parent_ptr      = ptr->parent;
        grandparent_ptr = ptr->parent->parent;

        // Caso A:
        // Pai é o filho esquerdo do avô
        if(parent_ptr == grandparent_ptr->left) {
            node_t* uncle_ptr = grandparent_ptr->right;

            // Caso 1:
            // O tio de ptr existe e também é vermelho:
            // Basta recolorir.
            if(uncle_ptr && uncle_ptr->color == RED) {
                grandparent_ptr->color = RED;
                parent_ptr->color      = BLACK;
                uncle_ptr->color       = BLACK;
                // Vá para o avô e refaça.
                ptr = grandparent_ptr;
            }
            // Mas se o tio é preto (ou é nulo)...
            else {
                
                // Caso 3:
                // ptr é o filho direito de seu pai:
                // requer uma rotação à esquerda.
                if(ptr == parent_ptr->right) {
                    _lrot(root, parent_ptr);
                    // Vá para o pai e continue.
                    ptr        = parent_ptr;
                    parent_ptr = ptr->parent;
                }

                // Caso 2:
                // ptr é o filho esquerdo de seu pai:
                // requer uma rotação à direita.
                _rrot(root, grandparent_ptr);

                // Troque as cores do avô e do pai
                {
                    COLOR c = parent_ptr->color;
                    parent_ptr->color = grandparent_ptr->color;
                    grandparent_ptr->color = c;
                }

                // Vá para o pai e continue.
                ptr = parent_ptr;
            }   
        }
        // Caso B:
        // Pai de ptr é o filho direito do avô de ptr
        else {
            node_t* uncle_ptr = grandparent_ptr->left;

            // Os casos abaixo são uma repetição do que ocorre
            // em A, porém com a direção das rotações e
            // ponteiros invertida.
            if(uncle_ptr && uncle_ptr->color == RED) {
                grandparent_ptr->color = RED;
                parent_ptr->color      = BLACK;
                uncle_ptr->color       = BLACK;
                ptr = grandparent_ptr;
            } else {
                if(ptr == parent_ptr->left) {
                    _rrot(root, parent_ptr);
                    ptr = parent_ptr;
                    parent_ptr = ptr->parent;
                }

                _lrot(root, grandparent_ptr);
                {
                    COLOR c = parent_ptr->color;
                    parent_ptr->color = grandparent_ptr->color;
                    grandparent_ptr->color = c;
                }
                ptr = parent_ptr;
            }
        }
    } // Fim do while

    // Independente de tudo, colora a raiz de preto
    _root->color = BLACK;
}
#+end_src

** Inserção

#+begin_src cpp
node_t *_bst_insert(node_t *root, node_t *ptr)
{
    // Se raiz está vazia, retorne um novo nó
    if(!root) return ptr;

    // Se não, recorra árvore abaixo
    if(ptr->info < root->info) {
        root->left         = _bst_insert(root->left, ptr);
        root->left->parent = root;
    } else if(ptr->info > root->info) {
        root->right         = _bst_insert(root->right, ptr);
        root->right->parent = root;
    }

    // Se o nó é igual a algum outro, retorne a
    // raiz sem mudanças
    return root;
}
#+end_src

#+begin_src cpp
bool _insert(T info)
{
    node_t* node = new node_t;
    node->info   = info;
    node->color  = RED;
    node->left   = nullptr;
    node->right  = nullptr;
    node->parent = nullptr;

    _root = _bst_insert(_root, node);
    if((!node->parent) && (node != _root)) {
        // Nó não inserido
        delete node;
        return false;
    }
    _fixup(_root, node);
    return true;
}
#+end_src

** Impressão

Os métodos a seguir demonstram a implementação de várias formas de
impressão dos elementos da árvore na tela, de acordo com o que foi
previamente descrito na Seção [[sec:impressao_enum]].

*** Impressão em ordem

Imprimir um nó /em ordem/ envolve imprimir recursivamente a sub-árvore
de seu filho esquerdo, imprimir seu próprio valor, e imprimir
recursivamente a sub-árvore de seu filho direito.

Como árvores binárias realizam inserções e remoções mantendo a
hierarquia dos elementos, a impressão /em ordem/, para este exemplo,
imprime os elementos da árvore em ordem crescente.

#+begin_src cpp
void _print_inorder(const node_t *node) const
{
    if(!node) return;
    _print_inorder(node->left);
    std::cout << node->info << ' ';
    _print_inorder(node->right);
}
#+end_src

*** Impressão em pré-ordem

Imprimir um nó /em pré-ordem/ envolve imprimir primeiramente o valor do
nó, e então imprimir recursivamente a sub-árvore dos filhos esquerdo e
direito deste nó, respectivamente.

#+begin_src cpp
void _print_preorder(const node_t *node) const
{
    if(!node) return;
    std::cout << node->info << ' ';
    _print_inorder(node->left);
    _print_inorder(node->right);
}
#+end_src

*** Impressão em pós-ordem

Imprimir um nó em /pós-ordem/ envolve, primeiramente, imprimir em
recursão a sub-árvore dos filhos direito e esquerdo, e então imprimir
o valor do nó atual.

#+begin_src cpp
void _print_postorder(const node_t *node) const
{
    if(!node) return;
    _print_inorder(node->left);
    _print_inorder(node->right);
    std::cout << node->info << ' ';
}
#+end_src

*** Impressão por nível

Impressão /por nível/ envolve imprimir, em sequência, todos os nós
existentes na árvore, em um formato linear. Note que esta impressão em
nível não deixa explícito o relacionamento entre os nós impressos.

Para realizar esta impressão, utilizamos uma /fila/ (=std::queue=) de
ponteiros para nós. À medida que nós são retirados do início da fila,
suas informações são impressas. Em seguida, os ponteiros para os
filhos esquerdo e direito deste nó, respectivamente, são enfileirados,
a não ser que sejam /nulos/. A impressão acaba quando não há mais nós na
fila.

#+begin_src cpp
void _print_bylevel(const node_t *node) const
{
    if(!node) return;
    std::queue<const node_t*> nodes;
    nodes.push(node);

    while(!nodes.empty()) {
        const node_t *front = nodes.front();
        nodes.pop();
        if(front) {
            nodes.push(front->left);
            nodes.push(front->right);
            std::cout << front->info << ' ';
        }
    }
}
#+end_src

*** Impressão triangular

A impressão /triangular/ é muito similar à impressão /por nível/, todavia
utilizamos /duas filas/ (=std::queue=) para realizar a impressão.

A ideia é que, ao invés de enfileirarmos os ponteiros dos nós-filhos
em uma única fila, enfileiramo-nos em uma fila de "próximo
nível". Quando a fila atual esvazia, quebramos uma linha na impressão,
e trazemos todos os elementos da fila de "próximo nível" para a fila
padrão.

Também realizamos a impressão conveniente de ponteiros nulos. Com esta
prática, passa a ser extremamente simples o ato de tomar uma saída
triangular e desenhar uma árvore binária apropriada em papel.

#+begin_src cpp
void _print_triangle(const node_t *node) const
{
    if(!node) return;
    std::queue<const node_t*> curr;
    std::queue<const node_t*> next;

    curr.push(node);

    while(!curr.empty()) {
        const node_t *front = curr.front();
        curr.pop();
        if(!front)
            std::cout << "*:B";
        else {
            next.push(front->left);
            next.push(front->right);
            std::cout << front->info << ':'
                      << (front->color == RED
                          ? 'R'
                          : 'B');
        }

        std::cout << ' ';
        if(curr.empty() && !next.empty()) {
            std::swap(curr, next);
            std::cout << std::endl;
        }
    }
}
#+end_src

*** Impressão GraphViz

#+begin_src cpp
void _gen_graphviz(std::ostream& oss, const node_t *node) const
{
    // Print graphviz header
    oss << "graph G {" << std::endl
        << "bgcolor=\"#00000000\";" << std::endl
        << "graph["
        // << "nodesep=\"0.5\", "
        << "ranksep = \"0.2\", "
        << "dpi = 150, "
        // << "splines = \"curved\", "
        << "fixedsize = true];" << std::endl
        << "node[shape=circle, "
        << "fontcolor=white, "
        << "fillcolor=white, "
        << "style=filled];" << std::endl;

    std::queue<const node_t*> nodes;
    if(node) nodes.push(node);

    int nullidx = 0;

    while(!nodes.empty()) {
        const node_t *front = nodes.front();
        nodes.pop();

        // Print node properties
        oss << front->info
            << "[fillcolor="
            << (front->color == RED
                ? "red"
                : "black")
            << "];" << std::endl;
        // Print node children
        if(front->left) {
            oss << front->info
                << ":sw -- "
                << front->left->info
                << ":n;"
                << std::endl;
            // Enqueue existing child
            nodes.push(front->left);
        } else {
            oss << "nil" << nullidx
                << "[label=\"nil\", "
                << "shape=plain, "
                << "fontsize=9, "
                << "style=\"\", "
                << "fontcolor=black]"
                << std::endl;
            oss << front->info
                << ":sw -- "
                << "nil" << nullidx
                << ';'
                << std::endl;
            nullidx++;
        }
        
        if(front->right) {
            oss << front->info
                << ":se -- "
                << front->right->info
                << ":n;"
                << std::endl;
            nodes.push(front->right);
        } else {
            oss << "nil" << nullidx
                << "[label=\"nil\", "
                << "shape=plain, "
                << "fontsize=9, "
                << "style=\"\", "
                << "fontcolor=black]"
                << std::endl;
            oss << front->info
                << ":se -- "
                << "nil" << nullidx
                << ';'
                << std::endl;
            nullidx++;
        }
    }
    
    oss << '}' << std::endl;
}
#+end_src

#+begin_src cpp
void _print_graphviz(const node_t *node) const
{
    _gen_graphviz(std::cout, node);
}
#+end_src

#+begin_src cpp
void _save_graphviz(const node_t *node) const
{
    std::ofstream out;
    out.open("/tmp/rbtree.dot");

    if(!out.is_open()) {
        std::cerr << "Erro ao gerar o arquivo" << std::endl;
        return;
    }

    _gen_graphviz(out, node);
    out.close();
}
#+end_src

#+begin_src cpp
void _show_graphviz(const node_t *node, bool interact = false) const
{
    _save_graphviz(node);

    if(!interact) {
        if(system("/usr/bin/dot /tmp/rbtree.dot -Kdot -Tpng -o /tmp/rbtree.png")) {
            std::cerr << "Erro ao gerar a imagem" << std::endl;
            return;
        }
        
        if(system("/usr/bin/feh /tmp/rbtree.png")) {
            std::cerr << "Erro ao mostrar a imagem" << std::endl;
            return;
        }
    } else {
        if(system("/usr/bin/xdot /tmp/rbtree.dot &")) {
            std::cerr << "Erro ao mostrar a arvore" << std::endl;
            return;
        }
    }
}
#+end_src

** Limpeza de sub-árvore

O método a seguir /limpa/ a sub-árvore do nó informado, incluindo o nó
atual e removendo todos os nós abaixo do mesmo.

Este não é um método de remoção propriamente dito, uma vez que o
intuito principal é realizar liberação de memória recursivamente. Este
método é melhor utilizado na /raiz/ da árvore; todavia, se chamado
diretamente, é necessário também fazer com que a raiz em questão
torne-se um ponteiro /nulo/, caso mais operações sejam esperadas.

#+begin_src cpp
void _clear(node_t* node)
{
    if(!node) return;
    _clear(node->left);
    _clear(node->right);
    delete node;
}
#+end_src

** Pesquisa

O método a seguir realiza uma pesquisa na árvore, procurando por uma
informação passada por referência.

O método realiza a pesquisa recursivamente, direcionando-a de acordo
com o valor da informação dada para determinar o ramo a ser
seguido. A resposta será um valor booleano.

#+begin_src cpp
bool _search(const node_t* node, const T& info) const
{
    if(!node) return false;

    if(node->info == info) return true;

    if(info < node->info) {
        return _search(node->left, info);
    }

    return _search(node->right, info);
}
#+end_src

* Elementos públicos

** Início dos elementos públicos
:PROPERTIES:
:UNNUMBERED: t
:END:

Os elementos após a próxima linha são acessíveis /também fora do escopo
da classe =RBTree=/.

#+begin_src cpp
public:
#+end_src

** Construtores

A classe =RBTree= possui dois construtores, onde ambos definem o
ponteiro para a raiz da árvore como um valor /nulo/.

O primeiro construtor realiza apenas esta atribuição padrão.

#+begin_src cpp
RBTree() : _root(nullptr) {}
#+end_src

O segundo construtor espera por um /vetor/ de valores do tipo =T=
informado via /template/. Após a inicialização do ponteiro para a raiz
da árvore, o construtor insere os valores informados pelo /vetor/ na
mesma, um a um.

É interessante notar que, pos tratar-se de um =std::vector=, o parâmetro
dos valores também pode ser fornecido como uma literal de um /vetor/
comum.

#+begin_src cpp
RBTree(std::vector<T> vals) : _root(nullptr)
{
    for(T val : vals)
        _insert(val);
}
#+end_src

** Destrutor

O destrutor da classe =RBTree= invoca o método interno de limpeza para
a sub-árvore. Como o destrutor é invocado como finalizador da classe,
não é necessário atribuir nulidade à raiz da mesma.

#+begin_src cpp
~RBTree()
{
    _clear(_root);
}
#+end_src

** Métodos externos

Os métodos a seguir constituem /invólucros/ para métodos internos da
árvore.

*** Inserção

Insere uma certa informação na árvore. Retorna um valor booleano
indicando o /status/ da inserção de tal informação.

#+begin_src cpp
bool insert(T info)
{
    return _insert(info);
}
#+end_src

*** Impressão

Imprime a árvore por inteiro, de acordo com o estilo de impressão
fornecido, segundo a enumeração demonstrada na Seção
[[sec:impressao_enum]].

Caso o programador opte por não informar o estilo de impressão, uma
impressão /em ordem/ será feita por padrão.

#+begin_src cpp
void print(TreePrintStyle style = TREEPRINT_INORDER) const
{
    switch(style) {
    case TREEPRINT_INORDER:
        _print_inorder(_root);
        break;
    case TREEPRINT_PREORDER:
        _print_preorder(_root);
        break;
    case TREEPRINT_POSTORDER:
        _print_postorder(_root);
        break;
    case TREEPRINT_LEVEL:
        _print_bylevel(_root);
        break;
    case TREEPRINT_TRIANGLE:
        _print_triangle(_root);
        break;
    case TREEPRINT_GRAPHVIZ:
        _print_graphviz(_root);
        break;
    case TREESHOW_GRAPHVIZ:
        _show_graphviz(_root);
        break;
    case TREESHOW_XDOT:
        _show_graphviz(_root, true);
        break;
    default: std::cout << "Unimplemented"; break;
    }
    std::cout << std::endl;
}
#+end_src

*** Limpeza

Limpa todos os elementos da árvore.

Este método atribui apropriadamente o valor de nulidade à raiz da
árvore, ao contrário do destrutor, pois pode ser invocado antes da
inserção de mais elementos.

#+begin_src cpp
void clear(void)
{
    _clear(_root);
    _root = nullptr;
}
#+end_src

*** Pesquisa

Pesquisa por um elemento na árvore, que será passado /por valor/ para
este método.

Retorna um valor booleano representando a existência do elemento na
árvore.

#+begin_src cpp
bool search(const T info) const
{
    return _search(_root, info);
}
#+end_src

*** Salvar (GraphViz)

#+begin_src cpp
void save_graphviz(void) const
{
    _save_graphviz(_root);
}
#+end_src

* Fim da classe RBTree
:PROPERTIES:
:UNNUMBERED: t
:END:

Este símbolo encerra a definição da classe =RBTree=.

#+begin_src cpp
};
#+end_src

* Testes

As funções a seguir determinam testes para o instanciamento e a
manipulação de elementos na árvore AVL.

** Impressão de elementos na tela

Esta função generaliza a impressão dos elementos em uma árvore passada
/por referência/ como parâmetro. Normalmente, ela é invocada ao final de
cada teste.

Esta é uma função /inline/, portanto, no momento de compilação, seu uso
envolve uma "substituição direta" de seu conteúdo no corpo da função
que a invoca.

#+begin_src cpp
template<typename T>
inline void
test_debrief(RBTree<T>& tree)
{
    std::cout << "Arvore:" << std::endl;
    tree.print(TREEPRINT_TRIANGLE);
    std::cout << std::endl;
    std::cout << "Em ordem:  ";
    tree.print(TREEPRINT_INORDER);
    std::cout << "Preordem:  ";
    tree.print(TREEPRINT_PREORDER);
    std::cout << "Pos-ordem: ";
    tree.print(TREEPRINT_POSTORDER);
    std::cout << std::endl;
    tree.save_graphviz();
}
#+end_src

** Teste de inserção

Este teste insere certos elementos, um a um, em uma =RBTree= de números
inteiros, mostrando impressões /em ordem/ e /por nível/ após cada
inserção.

#+begin_src cpp
void
test_raw(void)
{
    std::cin.sync();
    std::cin.get();
    std::cout << "## Insercao de elementos, um a um"
              << std::endl;
    RBTree<int> tree;
    for(const int num : {0, 3, 6, 2, 1, 4, 90, 36, 49}) {
        std::cout << "-- Inserindo: " << num << std::endl;
        tree.insert(num);
        test_debrief<int>(tree);
        std::cout << "Pressione uma tecla para continuar." << std::endl;
        std::cin.sync();
        std::cin.get();
    }
    std::cout << std::endl;
}
#+end_src

** Teste de construtor

Esta função testa o uso do construtor alternativo da classe =RBTree=
para números inteiros, através da passagem de uma literal de vetor
numérico.

#+begin_src cpp
void
test_ctor(void)
{
    std::cin.sync();
    std::cin.get();
    std::cout << "## Insercao de elementos via construtor"
              << std::endl;
    RBTree<int> tree({35, 39, 51, 20, 13, 28, 22, 32, 25, 33});

    test_debrief<int>(tree);

    std::cout << "Pressione uma tecla para continuar." << std::endl;
    std::cin.sync();
    std::cin.get();
    std::cout << std::endl;
}
#+end_src

** Teste de caracteres

Esta função usa o construtor alternativo da classe =RBTree= para
construir uma árvore RB de /caracteres/.

#+begin_src cpp
void
test_char(void)
{
    std::cin.sync();
    std::cin.get();
    std::cout << "## Arvore de caracteres" << std::endl;
    RBTree<char> tree({'M', 'G', 'B', 'H', 'S', 'P', 'F', 'C'});

    test_debrief<char>(tree);

    std::cout << "Pressione uma tecla para continuar." << std::endl;
    std::cin.sync();
    std::cin.get();
    std::cout << std::endl;
}
#+end_src

** Teste de pesquisa

Esta função testa a pesquisa de alguns elementos em uma =RBTree= de
números inteiros.

#+begin_src cpp
void
test_search(void)
{
    std::cin.sync();
    std::cin.get();
    std::cout << "## Teste de pesquisa" << std::endl;
    RBTree<int> tree({5, 9, 30, 2, 20, 32});

    test_debrief<int>(tree);

    for(int num : {2, 5, 31, 44}) {
        std::cout << num << " esta na arvore? "
                  << (tree.search(num) ? 'T' : 'F')
                  << std::endl;
    }
    std::cout << std::endl;

    std::cout << "Pressione uma tecla para continuar." << std::endl;
    std::cin.sync();
    std::cin.get();
    std::cout << std::endl;
}
#+end_src

** Menu de testes

#+begin_src cpp
void
test_menu(void)
{
    char c = 0;
    do {
        std::cout << "1. Teste de insercao\n"
                  << "2. Teste de construcao\n"
                  << "3. Teste de uso com caracteres\n"
                  << "4. Teste de pesquisa\n"
                  << "0. Voltar\n"
                  << "Opcao: ";
        std::cin.sync();
        c = std::cin.get();
        std::cin.sync();

        switch(c) {
        case '1':
            test_raw();
            break;
        case '2':
            test_ctor();
            break;
        case '3':
            test_char();
            break;
        case '4':
            test_search();
            break;
        default: break;
        };
    } while ('0' != c);
}
#+end_src

** REPL

Esta função recebe entradas numéricas passo a passo e tenta inseri-las
em uma =RBTree= numérica. Além disso, suporta alguns comandos extras.

#+begin_src cpp
void
repl(void)
{
    srand(time(NULL));
    RBTree<int> tree;
    tree.save_graphviz();

    std::cout << "Para ajuda, digite \'help\'."
              << std::endl;
        
    std::string input;
    do {
        std::cout << "> ";
        std::cin >> std::ws;
        std::getline(std::cin, input, '\n');
        if(input == "clear") {
            std::cout << "Limpando a arvore..."
                      << std::endl;
            tree.clear();
            tree.save_graphviz();
        } else if(input == "show") {
            tree.print(TREESHOW_GRAPHVIZ);
        } else if(input == "inter") {
            tree.print(TREESHOW_XDOT);
        } else if(input == "inorder") {
            tree.print(TREEPRINT_INORDER);
        } else if(input == "preorder") {
            tree.print(TREEPRINT_PREORDER);
        } else if(input == "postorder") {
            tree.print(TREEPRINT_POSTORDER);
        } else if(input == "levels") {
            tree.print(TREEPRINT_LEVEL);
        } else if(input == "triangle") {
            tree.print(TREEPRINT_TRIANGLE);
        } else if(input == "graphviz") {
            tree.print(TREEPRINT_GRAPHVIZ);
        } else if(input == "refresh") {
            tree.save_graphviz();
        } else if(input == "rand") {
            int num = rand() % 100;
            bool result = tree.insert(num);
            tree.save_graphviz();
            if(result) {
                std::cout << num << std::endl;
            } else {
                std::cout << num
                          << " ja esta na arvore!"
                          << std::endl;
            }
        } else if(input == "test") {
            test_menu();
        } else if(input == "help") {
            std::cout << "Comandos disponiveis:\n"
                      << "refresh   Atualiza a arvore em disco.\n"
                      << "clear     Limpa a arvore.\n"
                      << "show      Mostra a arvore numa imagem.\n"
                      << "inter     Mostra a arvore na ferramenta xdot.\n"
                      << "inorder   Impressao em-ordem.\n"
                      << "preorder  Impressao pre-ordem.\n"
                      << "postorder Impressao pos-ordem.\n"
                      << "levels    Impressao em niveis.\n"
                      << "triangle  Impressao triangular.\n"
                      << "graphviz  Imprime codigo GraphViz.\n"
                      << "rand      Adiciona numero aleatorio.\n"
                      << "help      Mostra este texto.\n"
                      << "test      Menu de testes pre-prontos.\n"
                      << "<numero>  Adiciona o numero a arvore.\n"
                      << "quit      Sai deste console.\n"
                      << std::endl;
        } else if(input != "quit") {
            try {
                int num = std::stoi(input);
                bool result = tree.insert(num);
                tree.save_graphviz();
                if(!result) {
                    std::cout << num
                              << " ja esta na arvore!"
                              << std::endl;
                }
            } catch(const std::invalid_argument& e) {
                std::cout << "Comando desconhecido"
                          << std::endl;
            } catch(const std::out_of_range& e) {
                std::cout << "Numero informado e grande demais"
                          << std::endl;
            }
        }
    } while(input != "quit");
}
#+end_src

* Ponto de entrada

Esta é a função principal da aplicação, constituindo o ponto de
entrada da mesma. Utilizamos este ponto de entrada para executar o
REPL.

#+begin_src cpp
int
main(void)
{
    std::cout << "Teste de Arvore Red-Black"
              << std::endl;
    repl();
    return 0;
}
#+end_src

* Compilação

O código a seguir constitui um arquivo /Makefile/ para a compilação do
arquivo em questão.

#+begin_src makefile :tangle Makefile
CXX      := clang++ --std=c++14
CXXFLAGS := -Wall -pedantic -g
OUTFLAG  := -o
BINARY   := rbtree
SRC      := rbtree.cpp

all: $(BINARY)

$(BINARY): $(SRC)
	$(CXX) $(CXXFLAGS) $^ $(OUTFLAG) $@
#+end_src

# <<bibliographystyle link>>
# bibliographystyle:unsrt

<<bibliography link>>
bibliography:referencias.bib

* Footnotes

[fn:1] Ou seja, o tipo dado a =T= deverá ser comparável através da
utilização de operadores aritméticos de comparação. 
