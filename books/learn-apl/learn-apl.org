#+TITLE:    Learn APL notes
#+AUTHOR:   Lucas Vieira
#+EMAIL:    lucasvieira@protonmail.com
#+PROPERTY: header-args :tangle learn-apl.apl

* Startup

This file follows the [[https://aplwiki.com/LearnApl/TutorialContents][APL tutorial at APL Wiki]].

Also see the [[https://www.gnu.org/software/apl/apl.html][GNU APL Manual]].

Let's make sure our file executes. Executing the tangled file will run
everything done in the tutorial.

Also, for live interaction, use =gnu-apl-interactive-send-*=.

#+begin_src gnu-apl
#!/usr/bin/apl --id 1010
#+end_src

Oh, and just so you know, use a unicode font which supports this stuff.

* Simple arithmetic

Use =⍝= at the beginning of any comment.

#+begin_src gnu-apl
⍝ This is a comment.
⍝ Check the GNU APL keyboard for shortcut hints
⍝ at any time.

⍝ Simple Arithmetic
#+end_src

** Arithmetic functions

#+begin_src gnu-apl
5+12

18÷3
108÷11

4×7
3.893×7.6
#+end_src

Use =-= for subtraction, and =¯= for negative signal.

#+begin_src gnu-apl
100-95
8-16
#+end_src

** Arithmetic on lists of numbers

#+begin_src gnu-apl
3+2 4 11 7 5
#+end_src

Spot the difference on applying a sum to each element and applying a
sum on two numbers:

#+begin_src gnu-apl
1+2 3 4
1+234
#+end_src

Lists can be on either side of the sign.

#+begin_src gnu-apl
6 3 8 1+3
2.5 33.7 12 8÷15
9.8 11.2 17 1.2×1.175
#+end_src

It is possible to perform arithmetic between two lists in a
per-element basis, but only if their length matches.

#+begin_src gnu-apl
12 3 29 4×1 3 5 2
#+end_src

** Order of execution

APL runs stuff from right to left, since there are so many functions
on the language.

#+begin_src gnu-apl
3×3-1
#+end_src

That is because APL groups things from right to left as well.

#+begin_src gnu-apl
2 3 1+8÷2 2 2
#+end_src

If you need to make things unambiguous, use parentheses.

#+begin_src gnu-apl
(2 3 1+8)÷2 2 2
#+end_src

Remember again the difference between =-= and =¯=!

#+begin_src gnu-apl
1985 - 1066       ⍝ Difference of two numbers
3 ¯1 ¯7 + ¯4 ¯1 2 ⍝ Sum between two lists with negative numbers

2-3+5             ⍝ This does 3+5, then does 2-8
2 ¯3+5            ⍝ This adds 5 to the number list 2 ¯3
#+end_src

** Dual-purpose functions

Some functions can be used for more than one purpose.

When used in infix notation, ordinary operations have their intended
effect:

#+begin_src gnu-apl
5+4
1 3 4+3 1 6
#+end_src

You can, however, use the functions in prefix notation, which will
change their effect.

=+= appears to do nothing. Its true usage happens for assignment, which
we'll see next.

#+begin_src gnu-apl
+12
#+end_src

=-= inverts the signal of al numbers on the list.

#+begin_src gnu-apl
- 3 ¯6 ¯8 4 12 ¯9
#+end_src

=÷= takes the reciprocal of all numbers (divides 1 by them).

#+begin_src gnu-apl
÷1 2 4 10 100
#+end_src

=×= takes the sign of each number from the list. Yields =1= for positive
numbers, =¯1= for negative, and =0= for zero.

#+begin_src gnu-apl
×8 0 ¯3 ¯7 0 4
#+end_src

There is no definition for postfix operators; that would be a syntax
error.

** Ceiling and floor

- =⌈= rounds a number up;
- =⌊= rounds a number down.

To perform accurate rounding, you may want to use one of the following
patterns:

#+begin_src gnu-apl
⌈120.11 12.32 65.01 13.52 - 0.5
⌊99.99 12.82 15.39 48.90 + 0.5
#+end_src

When using those operators under an infix form, =⌈= selects the greatest
number, while =⌊= selects the smallest number.

#+begin_src gnu-apl
2 ⌈ 6
2 ⌊ 6
#+end_src

One can also use these operations to perform comparisions between
lists of numbers.

#+begin_src gnu-apl
6 8 1 ⌈ 3 5 9
6 8 1 ⌊ 3 5 9
#+end_src

** Ending a session

If you want to end a session, use

#+begin_src gnu-apl :tangle no
)OFF
#+end_src

This will not be tangled.

** Exercises

#+begin_src gnu-apl
⍝ Exercises
#+end_src

*** Q1

Enter statements to:

- Multiply each of three numbers, =3 6 2= by =8= and then add =4= to the
  results of the multiplication.

#+begin_src gnu-apl
4 + 8 × 3 6 2
#+end_src

- Add 15% to each number in the list =14 5 78 145=.

#+begin_src gnu-apl
1.15 × 14 5 78 145
#+end_src

- Add the difference between =13= and =8= to =4 6 12 7=.

#+begin_src gnu-apl
(13 - 8) + 4 6 12 7
⍝ Or...
4 6 12 7 + 13 - 8
#+end_src

- Multiply the result of =6= times =3= by the result of =4= times =8= and
  subtract =5= from the total.

#+begin_src gnu-apl
((6 × 3) × (4 × 8)) - 5
⍝ Or...
¯5+(6×3)×4×8
#+end_src

- Reverse the signs in this list: =3 ¯4 ¯12 6=

#+begin_src gnu-apl
- 3 ¯4 ¯12 6
#+end_src

- Compare these lists, selecting the larger number in each
  comparision:
  - =2 7 0 55=
  - =33 1 10 13=

#+begin_src gnu-apl
2 7 0 55 ⌈ 33 1 10 13
#+end_src

*** Q2

Which of these statements cause error messages? Why?

- Statement =a= is a valid multiplication between =12= and =9=.
- Statement =b= is a valid sum between =3= and =¯2=.
- Statement =c= produces a =LENGTH ERROR= because =19 0 3 4= and =7 2 87= are
  lists of different lengths.
- =5 ¯8= is a valid list of two numbers; it may be unintended, though.

*** Q3 

You're getting =£200= worth of dollars for yourself and =£180= and =£230=
worth respectively for two friends. Enter a statement which calculates
how many dollars each of you will get at =1.96= dollars to the pound.

#+begin_src gnu-apl
200 180 230×1.96
#+end_src

*** Q4

Highest recorded temperatures for a week in August were:

- =79 84 83 78 74 69 70= (Fahrenheit)

Enter a statement to convert them into Centigrade. (One method is to
subtract 32 degrees and multiply by 5/9.) Suppress decimal places in
the result.

#+begin_src gnu-apl
⌊((79 84 83 78 74 69 70-32)×5÷9)+0.5
⍝ Or...
⌈¯0.5+(5÷9)×79 84 83 78 74 69 70-32
#+end_src

*** Q5

Enter a statement to find the difference in metres between 1500 metres
and a mile. (1 yard = 0.9144m and 1760 yards in a mile)

#+begin_src gnu-apl
¯1500+1760×0.9144
#+end_src

* Variables

#+begin_src gnu-apl
⍝ Variables
#+end_src

** Assignments

An assignment can be done with a variable name and a =←= symbol.

#+begin_src gnu-apl
A ← .175
#+end_src

This enables =A= to be used in expressions.

#+begin_src gnu-apl
200×A
A×30.50 12.25 60.30 15.00
⌈ A×30.50 12.25 60.30 15.00
#+end_src

=C= is the conversion factor for fonverting pounds to kilograms.

#+begin_src gnu-apl
C ← .45359237
17 × C        ⍝ Convert 17 lbs into Kg
⌈C×11×14      ⍝ How many Kgs are there in 11 stones,
              ⍝ then round up
#+end_src

To keep a calculation, we then use variables.

#+begin_src gnu-apl
JOE ← ⌈C×11×14
#+end_src

** Variable names

Valid statements:

#+begin_src gnu-apl
AAA ← 4
ab ← 1
C9999 ← 0
Jack_Smith ← 100
#+end_src

Which denotes that APL is case sensitive.

Also, APL doesn't have bare words as variable names:

#+begin_src gnu-apl :tangle no
JOHN SMITH ← 100
#+end_src

However, using parentheses will create two identical variables with
the same value. This happens in both GNU APL and Dyalog.

#+begin_src gnu-apl :tangle no
(JOHN SMITH) ← 100 ⍝ Creates JOHN with value 100
                   ⍝ and SMITH with value 100
#+end_src

And if you start a variable name with a single number, the number will
be printed right after the value, which is assigned to the variable
name that follows:

#+begin_src gnu-apl :tangle no
5B ← 12
#+end_src

** Assigning lists to variables

#+begin_src gnu-apl
PRICE ← 12.45 5.60 5.99 7.75
+VAT   ← PRICE × A ⍝ A was assigned earlier
#+end_src

The =+= operator, when put before an assignment, forces a declarative
behaviour on the assigned variable -- in other words, forces the
variable to be displayed.

Using an unassigned variable causes a =VALUE ERROR=.

** System commands

The =)OFF= command has already been presented earlier.

=)VARS= lists all variables in the workspace.

#+begin_src gnu-apl
)VARS
#+end_src

=)WSID= shows the identity of the current workspace, which defaults to
=CLEAR WS=.

#+begin_src gnu-apl
)WSID
#+end_src

This command can also be used to change the identity of the
workspace; we change its name to =NEW=. The variables in it won't
change.

#+begin_src gnu-apl
)WSID NEW
#+end_src

To remove the variables (and the name), we can use =)CLEAR=.

#+begin_src gnu-apl
)CLEAR
#+end_src

** Character assignments

APL doesn't only deals with numbers, it can also deal with text. Just
apply quotes.

#+begin_src gnu-apl
A ← 'APL WILL PROCESS TEXT'
C ← 'CHARACTERS'
#+end_src

To insert quotes inside the text, use =''=.

#+begin_src gnu-apl
NAME ← 'WHAT''S IN A NAME? '
#+end_src

Other way to do that is by using double quotes around the characters.

#+begin_src gnu-apl :tangle no
NAME ← "WHAT'S IN A NAME? "
#+end_src

Consider the following variables.

#+begin_src gnu-apl
N ← 'NET PRICE'
QTY ← '230'
#+end_src

Attempting to perform arithmetic on text generates a =DOMAIN ERROR=:

#+begin_src gnu-apl :tangle no
N×10
QTY+5
#+end_src

** Multiple assignments

One can assign one value to multiple variables at the same time:

#+begin_src gnu-apl
(ZAK YAK) ← 5
#+end_src

Or assign many values to many variables at the same time too:

#+begin_src gnu-apl
(YEN MARK BUCK) ← 10 20 30
#+end_src

** Displaying variables together

This part is straightforward.

#+begin_src gnu-apl
N 10
NAME C

X ← 18
Y ← 3 1985
X Y

NAME X C

'NET PRICE: ' 10
#+end_src

** Joining lists

When writing =X Y=, these values were joined in a list of two
elements. The first element was the number in =X=, the second was the
two-element list in =Y=.

Let's store this result.

#+begin_src gnu-apl
Z ← X Y
#+end_src

Operations done in =Z= will not affect =X= and =Y= (also notice how =+10= maps
elegantly into sublists!!!):

#+begin_src gnu-apl
Z ← Z+10
#+end_src

Example with characters.

#+begin_src gnu-apl
CNAME ← 'BASIL '
SNAME ← 'BRUSH'
NAME  ← CNAME SNAME
#+end_src

Notice, though, that =NAME= is a list of two elements, each being a list
of characters; this is called a /nested variable/.

*** Extra stuff

This was learned from experimentation:

The operator =⍴= (rho) gives us the number of elements in a nested
variable, when used in prefix form.

In its infix form, =⍴= takes a number (left) of elements from the nested
variable (right).

#+begin_src gnu-apl
⍴NAME
1⍴NAME
#+end_src

** Joining and merging variables

The comma (=,=) allows APL to catenate lists.

#+begin_src gnu-apl
NAME ← CNAME,SNAME
#+end_src

One can see that the variable indeed became a non-nested list of 11
characters.

#+begin_src gnu-apl
⍴NAME
#+end_src

** Simple and nested variables

Single numbers (separated by spaces) and characters make up lists.

#+begin_src gnu-apl
PIERRE ← 1 2 3 4
MIREILLE ← 'FILLE'
#+end_src

Numbers enclosed in parentheses are treated as single items, so now
=PIERRE= will be a list, containing two lists.

#+begin_src gnu-apl
PIERRE ← (1 2 3) (4 5 6 7)
#+end_src

A list of character lists is easier, just enclose each sublist in
quotes (if you were to put it in a single, simple list, you'd put
everyone under the same quotes anyway):

#+begin_src gnu-apl
FRANCOISE ← 'UNE' 'JEUNE' 'FILLE'
#+end_src

** Mixed variables

This is not good for arithmetic, but it's useful to store characters
and numbers together.

#+begin_src gnu-apl
PHONES ← 'BILL' 577332 'FRANK' 886331
#+end_src

** Exercises

Let's start with a clean workspace.

#+begin_src gnu-apl
)CLEAR
#+end_src

*** Q1

Enter statements which:

- Assign the numbers =22 2 2007= to three variables called respectively
  =D=, =M= and =Y=.

#+begin_src gnu-apl
(D M Y) ← 22 2 2007
#+end_src

- Assign the characters =TODAY'S DATE:= to a variable called =DATE=.

#+begin_src gnu-apl
DATE ← 'TODAY''S DATE: '
#+end_src

- Produce the display: =TODAY'S DATE: 22 2 2007=

#+begin_src gnu-apl
DATE D M Y
#+end_src

*** Q2

Set up a variable =CONV= which contains a constant for converting pounds
to kilos. (1lb = 0.454Kg and 14lb = 1 stone). Use =CONV= to convert your
weight (to the nearest stone) into kilograms. Reduce the result by
10%, round it down, and display it.

#+begin_src gnu-apl
⍝ 1 stone = 14 lbs.
⍝ 1 lb    = 0.454 Kg.
⍝ Let's pretend I weight 11.5 stones.
CONV     ← .454
MYWEIGHT ← ⌊11.5×CONV×14×.9
MYWEIGHT
#+end_src

*** Q3

The cost prices of four items of stock are £8, 6, 12, 4
respectively. The markup on these items is 100%. Three other items
cost respectively £16, 13 and 7. Their markup is 75%. Calculate the
fully inclusive price of each item (with VAT at 17%). Display the
prices (rounded up) with the caption: ='PRICE+VAT: '=

#+begin_src gnu-apl
ITEMS_A ← 2×8 6 12 4
ITEMS_B ← 1.75×16 13 7
ITEMS   ← ⌈1.17×ITEMS_A,ITEMS_B
'PRICE+VAT: ' ITEMS
#+end_src

*** Q4

=TEST1= contains a student's exam marks for each of seven subjects (65
72 54 80 67 60 59). =TEST2= contains his marks for the same subjects
gained at a different test (75 70 60 74 58 61 50). Produce a list
consisting of his higher mark for each subject.

#+begin_src gnu-apl
TEST1 ← 65 72 54 80 67 60 59
TEST2 ← 75 70 60 74 58 61 50
TEST1 ⌈ TEST2
#+end_src

*** Q5

Which of the following will produce error messages? Why?

- The expression =RATE ← '3.7×3'= is a valid assignment of a list of
  characters, though it might be a logic error.
- The expression =10+10 '←21'= produces a =DOMAIN ERROR=, because it tries
  to sum =10= over a list containing the number =10= and the list of
  characters ='←21'=, which cannot perform arithmetic operations.
- The expression =100×RATE= produces a =DOMAIN ERROR=, because it tries to
  multiply by =100= over a list containing characters (=RATE=), which
  cannot perform arithmetic operations.
- The expression =SYMBOLS ← '¯<≤=≥'= is perfectly valid and creates a
  list of characters. But it might not be supported by some APL
  implementations (GNU APL supports it).
- The expression =3+'232'= produces a =DOMAIN ERROR=, because it tries to
  sum =3= over a list of characters, which cannot perform arithmetic
  operations.

** Cleanup

From now on, we clear the variables and the workspace across chapters.

#+begin_src gnu-apl
)CLEAR
#+end_src

* Tables

We won't be typing a lot of things here, that is insane! Let's see how
to generate our tables.

#+begin_src gnu-apl
⍝ Tables
#+end_src

** The Roll function

=?= is the Roll function, also called Random or Deal.

This generates numbers on range 1 to 100:

#+begin_src gnu-apl
? 100
#+end_src

The two-argument form generates a list of =n= (left) *unique* numbers from
1 to =m= (right):

#+begin_src gnu-apl
50 ? 100
#+end_src

In fact, it should always be true that =n ≤ m=, since the generated
numbers are unique. If not, we'll have a =DOMAIN ERROR=.

Both =n= and =m= can be replaced by variables as well.

** The Iota function

Iota, or Index, generates a sequence of numbers from 1 to =m= in its
one-argument form.

#+begin_src gnu-apl
⍳100
#+end_src

** Setting up tables

When entering tables, we use diadic for of the rho (=⍴=) function, also
called Shape or Reshape. The list before =⍴= states the order of the
table; the following elements are its rows, element by element.

#+begin_src gnu-apl
4 3 ⍴ 10 20 30 40 50 60 70 80 90 100 110 120
#+end_src

Let's generate twelve random numbers, then display them in a 4×3
table.

#+begin_src gnu-apl
DATA ← 12 ? 100
4 3 ⍴ DATA
#+end_src

If you feed =⍴= less numbers than expected, APL just keeps wrapping
these numbers. If you feed more than expected, APL uses just enough
numbers to build the table.

#+begin_src gnu-apl
4 3 ⍴ 1 2 3 4 5
#+end_src

And so follows that supplying one number fills the whole table:

#+begin_src gnu-apl
3 5 ⍴ 1
#+end_src

*** Extra bit

I wonder about identity matrices! Let's take a 3×3 matrix. If we type
a =1=, and then a number =n= of zeroes (corresponding to the matrix
order), then I suppose we can build an identity matrix...

#+begin_src gnu-apl
3 3 ⍴ 1 0 0 0
#+end_src

Indeed! But wait: I don't know how to build functions in APL yet, but
I suppose we can take this arbitrary number of zeroes and write them
in ⍴-notation too.

- Generate a list of =n= zeroes;
- Catenate a number =1= in front of it;
- Feed it as filling elements to the second ⍴.

#+begin_src gnu-apl
4 4 ⍴ 1,(4 ⍴ 0)
#+end_src

** Arithmetic on tables

Let's begin.

#+begin_src gnu-apl
SALES ← 3 3⍴20 13 8 30 43 48 3 50 21
SALES
#+end_src

Performing arithmetic on a table affects every number, just like in a
list.

#+begin_src gnu-apl
SALES×10
#+end_src

Let's set up another table.

#+begin_src gnu-apl
PRICES ← 2 3 ⍴ 21 2 12 47 33 1
#+end_src

This operation causes a =LENGTH ERROR=:

#+begin_src gnu-apl :tangle no
SALES×PRICES
#+end_src

This is because =SALES= is 3×3 while =PRICES= is 2×3. So let's reshape
=SALES= into a 3×2 table. This way, both of them will have the same
number of elements.

#+begin_src gnu-apl
SALES ← 3 2⍴SALES
#+end_src

But that still won't do... we're trying to multiply elements of same
address here, not make matrix multiplication. Let's try again.

#+begin_src gnu-apl
SALES ← 2 3⍴SALES
#+end_src

Ok, now we're good and we can proceed.

#+begin_src gnu-apl
TOTAL ← SALES×PRICES
SALES-PRICES
#+end_src

*** Extra bits

Let's build a nice table.

First table:
- Build a sequence from =1= to =25=.
- Create a =5×5= table with it.
- Take the reciprocal of each number.
- Multiply each element by =10=.

Second table:
- Take a sequence from =1= to =25=.
- Add =25= to each element.
- Create a =5×5= table with it.

Final table:
- Multiply each element of first table by each element of second
  table.
- Round every number by adding =¯.5= to each number and taking their
  ceiling.

#+begin_src gnu-apl
TOTAL ← ⌈¯.5+(5 5⍴25+⍳25)×10×÷5 5⍴⍳25
#+end_src

** Catenating tables

Catenating tables produce a big table. Each row is catenated like a
list. Therefore, catenated tables must have the same number of rows.

#+begin_src gnu-apl
SALES,PRICES
#+end_src

Let's test it a little more.

#+begin_src gnu-apl
LITTLE ← 2 2⍴1
MEDIUM ← 2 6⍴5
BIG    ← LITTLE,MEDIUM
#+end_src

To perform =LITTLE+MEDIUM=, we pad =LITTLE= with a table of zeroes.

#+begin_src gnu-apl
ZEROES ← 2 4⍴0
LITTLE ← LITTLE,ZEROES
LITTLE+MEDIUM
#+end_src

We could also have the zeroes on the other side; let's reset =LITTLE=
and do it.

#+begin_src gnu-apl
LITTLE ← 2 2⍴1
LITTLE ← ZEROES,LITTLE
LITTLE+MEDIUM
#+end_src

Since there is this kind of ambiguity, that is the reason why APL
doesn't do arithmetic on data of unequal size.

** Selecting elements

Let's set up a =4×3= table for the next example.

#+begin_src gnu-apl
+TABLE ← 4 3⍴2 12 15 4 11 7 1 16 8 20 19 9
#+end_src

Let's select the =9= in the bottom row, rightmost column.

#+begin_src gnu-apl
TABLE[4;3]
#+end_src

We sum the element at Row 1, Column 2 to the element at Row 2,
Column 2. Then we put it on Row 3, Column 2:

#+begin_src gnu-apl
TABLE[3;2] ← TABLE[1;2] + TABLE[2;2]
#+end_src

We can select more than one element in a row, or even in a column.

#+begin_src gnu-apl
TABLE[1;1 2]
TABLE[1 2;2]
#+end_src

To select entire rows or columns, omit the other parameter.

#+begin_src gnu-apl
TABLE[1;]
TABLE[;1]
#+end_src

Let's replace the numbers in column 3 with the sum of numbers in
columns 1 and 2.

#+begin_src gnu-apl
TABLE[;3] ← TABLE[;1] + TABLE[;2]
#+end_src

Also note that indexing can also be applied on lists.

#+begin_src gnu-apl
LIST ← 8 1 90 4
LIST[2]
#+end_src

** Dimensions

In APL, data has dimensions.

- Single numbers have dimension zero.
- A list has one dimension.
- The previous tables have two dimensions.
- Three-dimensional tables/arrays are like cubes, having depth, height
  and length.
- It is possible to create arrays of many dimensions in APL.

#+begin_src gnu-apl
SALES ← 6 4⍴24?50
#+end_src

In =SALES=, the salesmen are rows, the products are columns.
If we wanted to represent more than one region -- say, three regions
--, we'd need another dimension.

#+begin_src gnu-apl
+SALES ← 3 6 4⍴72?100
SALES[2;5;4]           ⍝ Plane 2, Row 5, Column 4
SALES[2;;]             ⍝ Plane 2
#+end_src

** Enquiring about the size of data

While the diadic usage of =⍴= involves creating arrays, the monadic
usage of =⍴= allows one to enquire about the size (or shape) of existing
tables, variables, etc.

#+begin_src gnu-apl
⍴SALES
#+end_src

Let's create some data.

#+begin_src gnu-apl
TABLE ← 5 3⍴15?20
LIST ← ⍳6
NUM ← 234
#+end_src

Now let's ask about their shape.

#+begin_src gnu-apl
⍴TABLE
⍴LIST
⍴NUM
#+end_src

Notice that, since =NUM= has no shape (equivalent to a point), APL gives
an empty response.

We don't need variables to do this kind of thing, though. We can apply
directly to literals.

#+begin_src gnu-apl
⍴12 61 502 1 26 0 11
⍴'SHAMBOLIOSIS'
#+end_src

** Tables of characters

This is also straightforward; characters are stored as a list of
characters. Let's do some experiments.

#+begin_src gnu-apl
⍝ Compare these two.
ALF ← 3 5⍴'ABCDE'
NUM ← 3 5⍴12345

MYNAME ← 'GORSUCH'
⍴MYNAME

3 7⍴MYNAME
3 14⍴MYNAME
3 18⍴MYNAME

MYNAME ← 'GORSUCH '
⍴MYNAME

3 40⍴MYNAME
#+end_src

Solution for the given example.

#+begin_src gnu-apl
4 11⍴'ADAMS      CHATER     PRENDERGASTLEE        '
#+end_src

** Mixed tables

We can build tables containing characters and numbers, just like the
lists.

#+begin_src gnu-apl
MIXTURE ← 3 3⍴'A' 1 'B' 'C' 2 'D' 'E' 3 'F'
#+end_src

*** Extra bits

You can't perform arithmetic in such a table, but you can of course
reshape it to do so. I built an example for that by myself:

#+begin_src gnu-apl
MIXTURE[;2] ← 10×MIXTURE[;2]
#+end_src

** Nested tables

Tables can contain other tables or lists.

#+begin_src gnu-apl
NEST ← 2 3⍴(2 2⍴⍳4) (⍳5) 'A NAME' (2 4⍴⍳8) 23 (3 4⍴'NAME')
⍴NEST
#+end_src

** Depth

The depth (=≡=) function shows the degree of nesting in a variable.

#+begin_src gnu-apl
≡45          ⍝ Values have depth 0
≡1 2 3       ⍝ Lists have depth 1
≡2 2⍴3 4 5 6 ⍝ Tables too
#+end_src

Now let's check the depth of =NEST=:

#+begin_src gnu-apl
≡NEST
#+end_src

When at least one element of a list or table is also a list or table,
the depth becomes 2; and so on, as long as you have child list/tables
inside child list/tables:

#+begin_src gnu-apl
BIG_NEST ← NEST NEST
⍴BIG_NEST
≡BIG_NEST
#+end_src

Since the components of =BIG_NEST= already have depth 2, =BIG_NEST= adds
one more layer of depth.

** Practice

Some interesting snippets showcasing the strength of APL: combining
functions.

#+begin_src gnu-apl
⍝ Playing with sizes of character lists
(⍴'ABC','DEF')+⍴'GHI'

⍝ Selecting the first nine numbers in row 1 of a big table
TABLE ← 10 10⍴100?100
TABLE[1;⍳9]
#+end_src

** Exercises

#+begin_src gnu-apl
)CLEAR
#+end_src

*** Q1

Set up a four-row one-column table called =MILES= containing =300 42 25
140=.

#+begin_src gnu-apl
MILES ← 4 1⍴300 42 25 140
#+end_src

And a similarly shaped table called =RATES= containing =27.5 15 27.5
27.5=.

#+begin_src gnu-apl
RATES ← 4 1⍴27.5 15 27.5 27.5
#+end_src

Multiply =RATES= by =MILES=, then multiply the result by =0.01= to produce a
table called =EXPENSES=.

#+begin_src gnu-apl
+EXPENSES ← .01×RATES×MILES
#+end_src

*** Q2

Change the number in column 1 row 3 of =MILES= from =25= to =250=. Again,
multiply =RATES= by =MILES= and the result by =0.01= to give =EXPENSES=, then
reformat =EXPENSES= to produce a one-row four-column table.

#+begin_src gnu-apl
MILES[3;1] ← 250
+EXPENSES   ← (.01×RATES×MILES)[;1]
#+end_src

Alternative way to change =EXPENSES=; interesting way to store and
immediately use a variable.

#+begin_src gnu-apl :tangle no
+EXPENSES ← 1 4⍴EXPENSES ← .01×RATES×MILES
#+end_src

*** Q3

Define =X= as a three-row ten-column table containing random numbers,
and =Y= as a three-row four-column table also containing random
numbers. Add =X= to =Y=, first taking whatever steps you think necessary
to enable the operation to take place.

#+begin_src gnu-apl
⍝ Defining the tables
X ← 3 10⍴30?30
Y ← 3 4⍴30+12?12

⍝ To sum Y into X, we catenate zeroes to Y,
⍝ extending it.
X+Y,3 ((⍴X)[2]-(⍴Y)[2])⍴0
#+end_src

Since the problem did not specify where to add the columns, here is an
alternative which catenates the zeroes to the left of =Y=:

#+begin_src gnu-apl :tangle no
X+(3 ((⍴X)[2]-(⍴Y)[2])⍴0),Y
#+end_src

*** Q4

Using table =X=, add the first and second rows and replace the third row
with the result of the addition.

#+begin_src gnu-apl
X[3;] ← X[1;]+X[2;]
#+end_src

*** Q5

Create a table which [displays =APL ROCKS= in vertical orientation]:

#+begin_src gnu-apl
9 1⍴'APL ROCKS'
#+end_src

*** Q6

What will be the result of each of these =⍴= statements? Predict each
result before you press ENTER.

- =⍴'ABC DEF'=\\
  → =7=
- =⍴480 0 1.2=\\
  → =3=
- =TABLE ← 10 10⍴100⍴1000=\\
  =⍴TABLE=\\
  → =10 10=
- =⍴'R'=\\
  → (empty)
- =⍴'480 0 1.2'=\\
  → =9=
- =TABLE ← 2 10 3⍴100⍴100=\\
  =⍴TABLE=\\
  → =2 10 3=

#+begin_notes
Recall why =⍴'R'= gives an empty response: a single value is equivalent
to a point, which has no size/dimension/shape.
#+end_notes

** Cleanup

#+begin_src gnu-apl
)CLEAR
#+end_src

* Writing a function

#+begin_src gnu-apl
⍝ Writing a function
#+end_src

** Precondition: the Slash operator

The Slash (=/=) or Reduce operator is not a function; it modifies or
extends the operation of the functions it is used with.

It works as if by putting the operator between the numbers.

#+begin_src gnu-apl
+/ 1 6 3 4
×/ 1 2 3 4
#+end_src

This can be done on a table too, however it will sum in a row basis.

#+begin_src gnu-apl
TABLE ← 3 3⍴⍳9
TABLE
+/ TABLE
#+end_src

We can, however, apply Reduce twice to obtain the entire sum.

#+begin_src gnu-apl
+/+/ TABLE
#+end_src

Useful combination: To select the largest number in a list, use =⌈=:

#+begin_src gnu-apl
⌈/ 75 72 78 90 69 77 81 88
#+end_src

The opposite equivalent (=⌊=) selects the smallest number:

#+begin_src gnu-apl
⌊/ 75 72 78 90 69 77 81 88
#+end_src

A final example: We take the sum of =X= (which is =15=) and divide it by
=X='s shape (=5=). This yields =3=, as expected of /calculating the average/
of a number.

#+begin_src gnu-apl
X ← ⍳5
(+/ X)÷⍴X
#+end_src

*** Axis arguments

You can apply the Reduce operator on a per-column basis using axis
arguments. For example, these two are equivalent, since they take the
dimension zero (rows):

#+begin_src gnu-apl
+/TABLE
+/[]TABLE
#+end_src

If you wish to use the *columns* instead of the *rows*, just ask for axis
one:

#+begin_src gnu-apl
+/[1]TABLE
#+end_src

** User functions

Now we'll preserve statements.

It seems some APL editors have a built-in editor. For example, one can
use the following commands:

#+begin_src gnu-apl :tangle no
)EDIT MYFUNC ⍝ On modern editors
)ED MYFUNC   ⍝ On Dyalog
∇            ⍝ On older editors, and on GNU APL as well
#+end_src

GNU APL also calls a new buffer when defining a function, under
Emacs. We can also send the following region to the interpreter no
problem. We just need to type in the function (=∇=) operator, which
starts the input mode.

Typing =∇= again goes back to calculator mode.

#+begin_src gnu-apl
∇TRY1
  'Type some numbers: '
  NUM ← ⎕   ⍝ Asks for user input
  'Total is: ' (+/ NUM)
∇
#+end_src

In case this function doesn't work when typing, just use =∇TRY1= to
change its definition on the editor.

This defines a user function =TRY1=, which takes no arguments. The Quad
(=⎕=) operator calls in for user input.

You can edit a function such as =TRY1= anytime, by typing =∇TRY1= on the
REPL; other APL implementations will allow you to use the command
=)EDIT TRY1=, for example.

Here is another example:

#+begin_src gnu-apl
∇TRY2
  'Type some numbers: '
  NUM ← ⎕
  'You have entered' (⍴NUM) 'numbers'
∇
#+end_src

And as requested, here is a way to calculate the average of some
numbers:

#+begin_src gnu-apl
∇AVERAGE
  'Type some numbers:'
  NUM ← ⎕
  'Integer average of these numbers is:' (⌊(+/ NUM)÷⍴NUM)
∇
#+end_src

One more definition.

#+begin_src gnu-apl
∇TRY3
  'Type some numbers:'
  NUM ← ⎕
  'You have entered' (⍴NUM) 'numbers'
  'The biggest was' (⌈/ NUM)
  'The smallest was' (⌊/ NUM)
  'Sum of numbers is' (+/ NUM)
  'Integer average of numbers is' (⌊(+/ NUM)÷⍴NUM)
∇
#+end_src

** Saving a workspace

You can check out the user-defined functions in your workspace with
this command:

#+begin_src gnu-apl
)FNS
#+end_src

There are some extra variables as well (check by using =)VARS=), so we
need to erase them:

#+begin_src gnu-apl
)ERASE TABLE X
#+end_src

Now we'll save the current workspace. First let's set the workspace ID
to the filename where it should be salved.

Notice that we are using Unix notation and the XML extension. This is
a requirement for GNU APL.

#+begin_src gnu-apl
)WSID ./MyFirstWS.xml
#+end_src

Windows users, using NARS2000, should do something like:

#+begin_src gnu-apl :tangle no
)WSID 'c:\foo\MyFirstWS'
#+end_src

Now we use the command to save.

#+begin_src gnu-apl
)SAVE
#+end_src

My result was:

#+begin_example
      2019-08-06  12:56:35 (GMT-3) ./MyFirstWS.xml
#+end_example

Now we can safely clear the workspace.

#+begin_src gnu-apl
)CLEAR
#+end_src

To load the workspace again, use the load command with the file name.

#+begin_src gnu-apl
)LOAD ./MyFirstWS.xml
#+end_src

#+begin_notes
GNU APL instructs to use =)COPY= instead.
#+end_notes

** User functions with arguments

User functions can have no arguments, one argument or two arguments.

*** Monadic

We intent to build a function which averages the numbers in a list.
So let's define it.

#+begin_src gnu-apl
∇AV X
  (+/ X)÷⍴X
∇
#+end_src

Now we can use it properly.

#+begin_src gnu-apl
AV 12 7 3 1
AV 3 8 1 4
AV 192 4534 12 0 2

NUM ← ⍳5
AV NUM
#+end_src

*** Diadic

A diadic function should be declared with arguments to its left and
its right:

#+begin_src gnu-apl
∇A SUM B
  A+B
∇
#+end_src

** Using function results in other expressions

To do so, we need to rewrite the function to enable that. See this
rewriting of =AV=.

#+begin_src gnu-apl
∇R←AV X
  R←(+/ X)÷⍴X
∇
#+end_src

An example of usage:

#+begin_src gnu-apl
¯3 + AV 3 8 1 4
#+end_src

The same can be done to diadic functions.

#+begin_src gnu-apl
∇R←A SUM B
  R←A+B
∇
#+end_src

** Cleanup

#+begin_src gnu-apl
)ERASE NUM
)SAVE
)CLEAR
#+end_src

